\section{Related work}

To our knowledge, existing solutions to the problem of correct synchronization assume either the ability to prevent bad interleavings from the ability to roll back execution. We focus our survery of related research on solutions for optimizing the rollback mechanism, and also discuss works on synchronization synthesis based on static program analysis.

\paragraph{Rollback optimizations.} There are two main optimizations to decrease rollback overhead: reducing abort rate and reducing the extent to which a transaction rolls back upon detecting a conflict. Different solutions have been proposed along each of these directions.

Conflict detection is primarily based on violations of disjoint parallelism. That is, if two transactions perform simultaneous read/write or write/write accesses to the same memory location, then they are deemed conflicting. 
%
An effective approach to mitigate false conflicts is to leverage the built-in guarantees of concurrent data structures \cite{ppopp/HerlihyK08,Galois,TYFS:OOPSLA11}. As an example, two {\sf ConcurrentHashMap} instances that perform {\sf put} operations involving different keys may still appear to conflict as they both access the {\sf size} field.

Transactional boosting, developed by Herlihy and Koskinen~\cite{ppopp/HerlihyK08}, is a systematic methodology to specify the behavior of linearizable data-structure operations in terms of their semantic, rather than concrete, footprint. The Galois system, built by Kulkarni et al. \cite{Galois}, follows a similar approach while focusing on the {\sf Graph} ADT in particular. The Hawkeye tool for detection of impediments to parallelization, by Tripp et al.~\cite{TYFS:OOPSLA11}, achieves the effect of abstract-level reasoning over memory accesses semi automatically by utilizing a mapping between the concrete and abstract representations of the data structure (albeit not its operations).  

In another study, Tripp et al.~\cite{TMFS:PLDI12} mine commutative behaviors involving \emph{multiple} operations out of execution traces of the program that appear to conflict when viewed at the granularity of individual operations. Conservative conditions under which the operation sequences commute are computed, such that at runtime, if the sequences manifest under these conditions, then false conflict is avoided.

Another approach to reduce conflict is to leverage available nondeterminism \cite{TKS:OOPSLA13}. If a transaction can choose between different nondeterministic behaviors (e.g., when selecting one among multiple elements in a container that satisfy a given property), then conflict is potentially reduced by directing the transaction toward a path that is less likely to conflict with other concurrent transactions.

A well-known solution to restrict the extent to which a transaction rolls back is checkpointing \cite{spaa08a,Egwutuoha:2013}. Checkpointing introduces the notion of a partial abort, where the transaction resumes from some intermediate point rather than fully resetting its execution and effects. Nested transactions \cite{ont,beeri} achieve a similar effect in that only the nested transaction, but not its parent transaction, aborts and restarts. Yet another mechanism to reduce rollback overhead is elastic transactions~\cite{FGG:DISC09}, which avoid wasted work by splitting into multiple pieces.  

\paragraph{Use of static analysis.} In our solution, static analysis is used to identify admissible shared-state configurations to warp to from a given input state. Multiple past works on synchronization synthesis have also relied on static analysis, albeit for the extraction of other types of information. We survey some of these works in the following.

Golan-Gueta et al.~\cite{GRSY:PLDI13} utilize static analysis to compute a conservative approximation of the possible actions that a transaction may perform in its future from a given intermediate point. This enables more granular synchronization compared to the worst-case assumption that the transaction may perform any action in its future.

In the Autolocker system for synchronization synthesis, McCloskey et al. \cite{popl/McCloskeyZGB06} apply static analysis to determine a correct locking policy, free of deadlocks and race conditions, given (i) a specification of pessimistic atomic sections and (ii) annotations that connect locks to shared sections. The analysis, encoded as a type system, guarantees that the choice and order of locks guarding each of the atomic sections will lead neither to deadlocks nor to races.

Hawkins et al. \cite{HawkinsAFRS12} propose a system to synthesize data representations for concurrent programs. The input is a program that consists, in part, of concurrent relations. The output is a representation of the relations as concrete concurrent data structures, as well as locks, that together ensure correct synchronization by construction. The aggregate set of operations is serializable and deadlock free.

	Prountzos et al. \cite{PrountzosMPM11} optimize the Galois system \cite{Galois} via static shape analysis \cite{MoolyToplas}. They apply the TVLA system to identify fail-safe points during the transaction's execution. This gives rise to two optimizations: (i) the transaction does not need to back up modified data, and (ii) redundant conflict checking can be eliminated. In Proznos et al.'s solution, the shape analysis, which is parametric in essence, is instantiated via a predicate discovery algorithm that exploits common patterns of data-structure usage.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
