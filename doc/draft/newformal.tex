\section{Transaction Semantics}

\subsection{Notation}

In our description of the transition system, we utilize the following semantic domains:
\\
\begin{tabular}{rcll}
	\\
	$T \subset {\cal T}$ & $:=$ & transaction IDs \\
	$c \in {\cal C}$ & $:=$ & command \\
	$\sigma \in \Sigma$ & $:=$ & shared state \\
	${\sigma_t}$ & $:=$ & local state of $t$ \\
	$L \in {\cal L}$ & $:=$ & shared log \\
	$L_t$ & $:=$ & local log of $t$ \\
	$s = (T, [t \mapsto (c_t,\sigma_t,L_t)]_{t \in T}, \Sigma, L) \in {\cal S}$ & $:=$ & system state \\
	\\
\end{tabular}
\\
We assume that the set $\Sigma$ of shared states is closed under composition, denoted $\cdot$. That is,
$\forall \sigma,\sigma' \in \Sigma.\ \sigma \cdot \sigma' \in \Sigma$. Hence, we can decompose a given shared state into (disjoint) substates (the standard decomposition being into memory locations), such that we can easily refer to the read/write effects of a given operation.

We additionally define two helper functions:
\begin{itemize}
\item $w \colon\ {\cal C} \times {\cal S} \rightharpoonup \Sigma$: the portion of the shared state written by a given atomic operation
\item $r \colon\ {\cal C} \times {\cal S} \rightharpoonup \Sigma$: the portion of the shared state read by a given atomic operation
\end{itemize}
The notation $\rightharpoonup$ denotes that $w$ and $r$ are partial functions. The shared log $L$ consists of pairs $\left\langle t,o \right\rangle$, where $t$ is a transaction identifier and $w(c) \neq \bot$.

\subsection{Transition System}

We define four transactional events, as follows:
\begin{itemize}
\item The {\sf bgn} event marks the beginning of a transaction.
\item The {\sf cmt} event fires when a transaction publishes its outstanding log of operations that affect the shared state to the shared state and log.
\item The {\sf end} event marks the termination of a transaction.
\item The {\sf warp} event enables a transaction to modify its local state and log, under certain restrictions, as a means to recover from potentially inadmissible thread interleavings.
\end{itemize}
We define the semantics of these events in the following. For rules where a transaction $t$ is defined in the prestate, its corresponding local configuration is denoted $(c_t,\sigma_t,L_t)$. We utilize helper function ${\sf serpref} \colon\ {\cal L} \rightarrow \{ {\sf true},{\sf false} \}$ to (conservatively) determine whether a given shared log is the prefix of some serializable execution log. Finally, we define helper function
${\sf ref} \colon\ {\cal T} \rightarrow {\cal S}$ that --- given a transaction $t$ --- retrieves the (global) system state immediately preceding $t$'s start.

The events are defined as follows:
\\
\begin{tabular}{rc}
\\
{\sf bgn}\ $(t,c)$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T \cup \{ t \}, \mu \cdot [t \mapsto (c,\bot,\epsilon)], \sigma, L)}{t \notin T}$ \\
\\
{\sf cmt}\ $(t)$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T, \mu[t \mapsto (c_t,\sigma_t,\epsilon)], \llbracket L_t \rrbracket(\sigma), L \cdot L_t)}{t \in T, L_t \neq \epsilon, {\textnormal{\sf serpref}\ L \cdot L_t}}$ \\
\\
{\sf end}\ $(t)$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T \setminus \{ t \}, \mu \setminus [t \mapsto \mu(t)], \sigma, L)}{t \in T, \mu(t) = ({\sf skip}, \_, \epsilon)}$ \\
\\
{\sf warp}\ $(t)$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T,\mu[t \mapsto (c'_t,\sigma'_t,L'_t)}{
\exists (c'_t,\sigma'_t,L'_t).\ {\sf ref}\ t = (T_0,\mu_0,\sigma_0,L_0) \leadsto (T,\mu[t \mapsto (c'_t,\sigma'_t,L'_t)],\sigma,L)}$ \\
\\
\end{tabular}
\\
dfdfd

\subsection{Other Stuff}

Events might be {\tt start}, {\tt read}, {\tt write}, {\tt warp}, {\tt commit}, {\tt abort}, and {\tt end}. Figure \ref{fi:semantics} formalizes the concrete semantics, where $a.b$ denotes the concatenation of sequence $a$ and sequence $b$, and $p_t$ represents the sequence of actions transaction $t$ performs.

\begin{figure*}
\begin{center}
\begin{tabular}{c}
\\
$\infer{\langle t, {\tt start}, (sh, tl, g, l)\rangle \to (sh, tl[t \mapsto (p_t, sh)], g, l[t \mapsto \epsilon])}{}$\\
\\
$\infer{\langle t, {\tt read}, (sh, tl, g, l)\rangle \to (sh, tl, g, l[t \mapsto l(t).{\tt read}])}{}$\\
\\
$\infer{\langle t, {\tt write}, (sh, tl, g, l)\rangle \to (sh, tl[t \mapsto \llbracket {\tt write}\rrbracket](tl(t)), g, l[t \mapsto l(t).{\tt write}])}{}$\\
\\
$\infer{\langle t, {\tt commit}, (sh, tl, g, l)\rangle \to (\llbracket l(t) \rrbracket(sh), tl, g.l(t), l\setminus [t \mapsto l(t)])}
{\textrm{if there is no conflict}}$\\
\\
$\infer{\langle t, {\tt commit}, (sh, tl, g, l)\rangle \to \langle t, {\tt warp}, (sh, tl, g, l)\rangle}
{\textrm{if there is a conflict}}$\\
\\
$\infer{\langle t, {\tt warp}, (sh, tl, g, l)\rangle \to (sh, tl[t \mapsto s], g, l[t \mapsto i])}
{\textrm{if the warping system produces state } s \textrm{ and  log } i}$\\
\\
$\infer{\langle t, {\tt end}, (sh, tl, g, l)\rangle \to (\llbracket l(t) \rrbracket(sh), tl \setminus [t \mapsto tl(t)], g.l(t), l\setminus [t \mapsto l(t)])}
{}$\\
\end{tabular}
\caption{Concrete semantics}
\label{fi:semantics}
\end{center}
\end{figure*}
