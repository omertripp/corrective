\section{Transaction Semantics}
\label{sec:concretesemantics}
\subsection{Notation}

In our description of the transition system, we utilize the following semantic domains:
\\
\begin{tabular}{rcll}
	\\
	$T \subset {\cal T}$ & $:=$ & transaction IDs \\
	$c \in {\cal C}$ & $:=$ & command \\
	$\sigma \in \Sigma$ & $:=$ & shared state \\
	${\sigma_t}$ & $:=$ & local state of $t$ \\
	$L \in {\cal L}$ & $:=$ & shared log \\
	$L_t$ & $:=$ & local log of $t$ \\
	$s = (T, [t \mapsto (c_t,\sigma_t,L_t)]_{t \in T}, \sigma, L) \in {\cal S}$ & $:=$ & system state \\
	\\
\end{tabular}
\\
We assume that the set $\Sigma$ of shared states is closed under composition, denoted $\cdot$. That is,
$\forall \sigma,\sigma' \in \Sigma.\ \sigma \cdot \sigma' \in \Sigma$. Hence, we can decompose a given shared state into (disjoint) substates (the standard decomposition being into memory locations), such that we can easily refer to the read/write effects of a given operation.

We additionally define two helper functions:
\begin{itemize}
\item $w \colon\ {\cal C} \times {\cal S} \rightharpoonup \Sigma$: the portion of the shared state written by a given atomic operation
\item $r \colon\ {\cal C} \times {\cal S} \rightharpoonup \Sigma$: the portion of the shared state read by a given atomic operation
\end{itemize}
The notation $\rightharpoonup$ denotes that $w$ and $r$ are partial functions. The shared log $L$ consists of pairs $\left\langle t,o \right\rangle$, where $t$ is a transaction identifier and $w(c) \neq \bot$.

\subsection{Transition System}
\label{sec:transitionsystem}

We define four transactional events, as follows:
\begin{itemize}
\item The {\sf bgn} event marks the beginning of a transaction.
\item The {\sf cmt} event fires when a transaction publishes its outstanding log of operations that affect the shared state to the shared state and log.
\item The {\sf end} event marks the termination of a transaction.
\item The {\sf warp} event enables a transaction to modify its local state and log, under certain restrictions, as a means to recover from potentially inadmissible thread interleavings.
\end{itemize}
We define the semantics of these events in the following. For rules where a transaction $t$ is defined in the prestate, its corresponding local configuration is denoted $(c_t,\sigma_t,L_t)$. We utilize helper function ${\sf serpref} \colon\ {\cal L} \rightarrow \{ {\sf true},{\sf false} \}$ to (conservatively) determine whether a given shared log is the prefix of some serializable execution log. Finally, we define helper function
${\sf ref} \colon\ {\cal T} \rightarrow {\cal S}$ that --- given a transaction $t$ --- retrieves the (global) system state immediately preceding $t$'s start.

The events are defined as follows:
\\
\begin{tabular}{rc}
\\
{\sf bgn}\ $t,c$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T \cup \{ t \}, \mu \cdot [t \mapsto (c,\bot,\epsilon)], \sigma, L)}{t \notin T}$ \\
\\
{\sf cmt}\ $t$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T, \mu[t \mapsto (c_t,\sigma_t,\epsilon)], \llbracket L_t \rrbracket(\sigma), L \cdot L_t)}{t \in T, L_t \neq \epsilon, {\textnormal{\sf serpref}\ L \cdot L_t}}$ \\
\\
{\sf end}\ $t$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T \setminus \{ t \}, \mu \setminus [t \mapsto \mu(t)], \sigma, L)}{t \in T, \mu(t) = ({\sf skip}, \_, \epsilon)}$ \\
\\
{\sf warp}\ $t$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T,\mu[t \mapsto \mu'(t)], \sigma, L)}{
	t \in T, 
	{\sf ref}\ t \leadsto (T,\mu', \sigma, L)}$\\
\\
{\sf local}\ $t$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T,\mu[t \mapsto (c'_t,\sigma'_t,L_t)], \sigma, L)}
{t \in T, \langle c_t,\sigma_t \rangle \to_l \langle c'_t,\sigma'_t \rangle}$\\
\\
\end{tabular}
\\
Note that the {\sf warp} rule only applies changes to the local configuration corresponding to the given transaction $t$. All other transactions retain their original local configurations.
In the {\sf local} rule, $\to_l$ represents the transition relation for local operations.

\subsection{Formal Guarantees}

\begin{theorem}[Soundness] Any terminating execution of the transition system is guaranteed to yield a serializable shared log.
\begin{proof}
	The {\sf cmt} event acts as a gatekeeper, demanding that the log prefix including the outstanding events about to be committed is serializable. The check executes atomically together with the log update. Hence the system is guaranteed to terminate with a serializable shared log.	
\end{proof}
\end{theorem}

\begin{definition}[Progress]
	We say that the transition system has made progress, transitioning from (global) state $s$ to (global) state $s'$, if the associated event $e$ for
	$s \stackrel{e}{\longrightarrow} s'$ is either a ${\sf cmt}$ event or an ${\sf end}$ event.
\end{definition}

\begin{definition}[Progress-safe warping]
	Let ${\sf warp}\ t$ occur at system state $s=(T,\mu,\sigma,L)$, such that state $s'=(T,\mu[t \mapsto (c_t,\sigma_t,L_t)],\sigma,L)$ is reached. Assume that there is a reduction
	$(\sigma_t,c_t,L_t) {\longrightarrow} (\sigma'_t,c'_t,L'_t)$, such that 
	at system state $s''=(T,\mu[t \mapsto (\sigma'_t,c'_t,L'_t)],\sigma,L)$ either (i)  ${\sf cmt}\ t$ is enabled or (ii) ${\sf end}\ t$ is enabled. Then we refer to ${\sf warp}\ t$ at $s$ with target $(\sigma_t,c_t,L_t)$ as \emph{progress safe}.
\end{definition}

Note that from the perspective of transaction $t$, the local states of other transactions are irrelevant to whether a commit (or end) transition is enabled for $t$. The only cause of a failed commit is if other threads have committed. We can therefore relax the definition above to refer to any system state $s''=(T',\mu',\sigma,L)$, such that $t \in T'$ and 
$[t \mapsto  (\sigma'_t,c'_t,L'_t)] \in \mu'$.

\begin{example}[Self warping]\label{Ex:selfwarp}
	Given transaction $t$ with local state $(\sigma_t,c_t,L_t)$, we refer to target
	$(\sigma'_t,c_t,L'_t)$ as a \emph{self-warping target}. Post warping, the transaction has the same command left to reduce, but its state and outstanding log of operations are modified. A specific instance is $(\sigma_t,{\sf skip},L_t) \rightarrow (\sigma'_t,{\sf skip},L'_t)$. This pattern of warping is progress safe if commits are attempted at join points, which enables simulation of alternative control-flow paths (and therefore also logged effects) via warping.
\end{example}

\begin{theorem}[Progress]\label{Th:progress} Assume that (i) a ${\sf warp}\ t$ event only fires when a transaction $t$ reaches a commit point but fails to commit, and (ii) warping instances are progress safe. Then progress is guaranteed.
	\begin{proof}
	Given system state $s$, if there exists a transaction $t$ that is able to either commit or complete then the proof is done. Otherwise, there is a transaction $t$ that reaches a commit point at some state $s'$ and fails. At this point, ${\sf warp}\ t$ is the only enabled transition for $t$, and by assumption (ii), the warping instance is progress safe. At this point, there are two possibilities. Either $t$ proceeds without other threads modifying the shared state, such that a commit or completion point is reached by $t$ (without warping prior to reaching such a point according to assumption (i)), in which case progress has been achieved, or one or more threads interfere with $t$ by committing their effects, in which case too progress has been achieved.
	\end{proof}
\end{theorem}

\begin{definition}[Complete warping] 
	We say that the system is complete w.r.t. warping if for any state $s$, if a ${\sf warp}\ t$ transition is executed in $s$, then the selected warping target satisfies progress safety.
\end{definition}

\begin{lemma}[Termination]
	Assume that the system performs warping only on failed commits, and is complete w.r.t. warping. Further assume that throughout any run of the system, only boundedly many transactions are created (via a {\sf bgn} event), and these transactions do not have infinite executions. Then termination is guaranteed.
	\begin{proof}
		The first two assumptions guarantee progress, as established above in 
		Theorem \ref{Th:progress}. Since transactions are finite, each transactions may perform finitely many {\sf cmt} transitions before terminating via an {\sf end} transition. This implies that after finitely many transitions, some transaction $t$ will terminate. This argument applies to the resulting system until no transactions are left.
	\end{proof}
\end{lemma}

\begin{example}[Loop parallelization]\label{Ex:loops}
	Assume the common case of loop parallelization, where loop iterations are executed in parallel as transactions. There are normally finitely many transactions, all starting at the same time, and all are expected to terminate within a finite number of steps. Complete on-commit-failure warping guarantees both termination and serializability in this setting.
\end{example}

%\subsection{Other Stuff}
%
%Events might be {\tt start}, {\tt read}, {\tt write}, {\tt warp}, {\tt commit}, {\tt abort}, and {\tt end}. Figure \ref{fi:semantics} formalizes the concrete semantics, where $a.b$ denotes the concatenation of sequence $a$ and sequence $b$, and $p_t$ represents the sequence of actions transaction $t$ performs.
%
%\begin{figure*}

%\begin{center}
%\begin{tabular}{c}
%\\
%$\infer{\langle t, {\tt start}, (sh, tl, g, l)\rangle \to (sh, tl[t \mapsto (p_t, sh)], g, l[t \mapsto \epsilon])}{}$\\
%\\
%$\infer{\langle t, {\tt read}, (sh, tl, g, l)\rangle \to (sh, tl, g, l[t \mapsto l(t).{\tt read}])}{}$\\
%\\
%$\infer{\langle t, {\tt write}, (sh, tl, g, l)\rangle \to (sh, tl[t \mapsto \llbracket {\tt write}\rrbracket](tl(t)), g, l[t \mapsto l(t).{\tt write}])}{}$\\
%\\
%$\infer{\langle t, {\tt commit}, (sh, tl, g, l)\rangle \to (\llbracket l(t) \rrbracket(sh), tl, g.l(t), l\setminus [t \mapsto l(t)])}
%{\textrm{if there is no conflict}}$\\
%\\
%$\infer{\langle t, {\tt commit}, (sh, tl, g, l)\rangle \to \langle t, {\tt warp}, (sh, tl, g, l)\rangle}
%{\textrm{if there is a conflict}}$\\
%\\
%$\infer{\langle t, {\tt warp}, (sh, tl, g, l)\rangle \to (sh, tl[t \mapsto s], g, l[t \mapsto i])}
%{\textrm{if the warping system produces state } s \textrm{ and  log } i}$\\
%\\
%$\infer{\langle t, {\tt end}, (sh, tl, g, l)\rangle \to (\llbracket l(t) \rrbracket(sh), tl \setminus [t \mapsto tl(t)], g.l(t), l\setminus [t \mapsto l(t)])}
%{}$\\
%\end{tabular}
%\caption{Concrete semantics}
%\label{fi:semantics}
%\end{center}
%\end{figure*}
