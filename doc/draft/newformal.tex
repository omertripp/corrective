\section{Transaction Semantics}

\subsection{Notation}

In our description of the transition system, we utilize the following semantic domains:
\\
\begin{tabular}{rcll}
	\\
	$T \subset {\cal T}$ & $:=$ & transaction IDs \\
	$c \in {\cal C}$ & $:=$ & command \\
	$\sigma \in \Sigma$ & $:=$ & shared state \\
	${\sigma_t}$ & $:=$ & local state of $t$ \\
	$L \in {\cal L}$ & $:=$ & shared log \\
	$L_t$ & $:=$ & local log of $t$ \\
	$s = (T, [t \mapsto (c_t,\sigma_t,L_t)]_{t \in T}, \sigma, L) \in {\cal S}$ & $:=$ & system state \\
	\\
\end{tabular}
\\
We assume that the set $\Sigma$ of shared states is closed under composition, denoted $\cdot$. That is,
$\forall \sigma,\sigma' \in \Sigma.\ \sigma \cdot \sigma' \in \Sigma$. Hence, we can decompose a given shared state into (disjoint) substates (the standard decomposition being into memory locations), such that we can easily refer to the read/write effects of a given operation.

We additionally define two helper functions:
\begin{itemize}
\item $w \colon\ {\cal C} \times {\cal S} \rightharpoonup \Sigma$: the portion of the shared state written by a given atomic operation
\item $r \colon\ {\cal C} \times {\cal S} \rightharpoonup \Sigma$: the portion of the shared state read by a given atomic operation
\end{itemize}
The notation $\rightharpoonup$ denotes that $w$ and $r$ are partial functions. The shared log $L$ consists of pairs $\left\langle t,o \right\rangle$, where $t$ is a transaction identifier and $w(c) \neq \bot$.

\subsection{Transition System}

We define four transactional events, as follows:
\begin{itemize}
\item The {\sf bgn} event marks the beginning of a transaction.
\item The {\sf cmt} event fires when a transaction publishes its outstanding log of operations that affect the shared state to the shared state and log.
\item The {\sf end} event marks the termination of a transaction.
\item The {\sf warp} event enables a transaction to modify its local state and log, under certain restrictions, as a means to recover from potentially inadmissible thread interleavings.
\end{itemize}
We define the semantics of these events in the following. For rules where a transaction $t$ is defined in the prestate, its corresponding local configuration is denoted $(c_t,\sigma_t,L_t)$. We utilize helper function ${\sf serpref} \colon\ {\cal L} \rightarrow \{ {\sf true},{\sf false} \}$ to (conservatively) determine whether a given shared log is the prefix of some serializable execution log. Finally, we define helper function
${\sf ref} \colon\ {\cal T} \rightarrow {\cal S}$ that --- given a transaction $t$ --- retrieves the (global) system state immediately preceding $t$'s start.

The events are defined as follows:
\\
\begin{tabular}{rc}
\\
{\sf bgn}\ $t,c$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T \cup \{ t \}, \mu \cdot [t \mapsto (c,\bot,\epsilon)], \sigma, L)}{t \notin T}$ \\
\\
{\sf cmt}\ $t$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T, \mu[t \mapsto (c_t,\sigma_t,\epsilon)], \llbracket L_t \rrbracket(\sigma), L \cdot L_t)}{t \in T, L_t \neq \epsilon, {\textnormal{\sf serpref}\ L \cdot L_t}}$ \\
\\
{\sf end}\ $t$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T \setminus \{ t \}, \mu \setminus [t \mapsto \mu(t)], \sigma, L)}{t \in T, \mu(t) = ({\sf skip}, \_, \epsilon)}$ \\
\\
{\sf warp}\ $t$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T,\mu[t \mapsto \mu'(t)], \sigma, L)}{
	t \in T, 
	{\sf ref}\ t \leadsto (T,\mu', \sigma, L)}$\\
%{\sf warp}\ $(t)$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T,\mu[t \mapsto (c'_t,\sigma'_t,L'_t)], \sigma, L)}{
%t \in T, 
%{\sf ref}\ t \leadsto (T,\mu [t \mapsto (c'_t, \sigma'_t, L'_t) ], \sigma, L)}$\\
%\\
%{\sf warp}\ $(t)$ & $\infer{(T, \mu, \sigma, L) \rightarrow (T,\mu[t \mapsto \mu'(t)], \sigma, L)}{
%	\exists (T_0,\mu_0,\sigma_0,L_0).
%	{\sf ref}\ t = (T_0,\mu_0,\sigma_0,L_0) \leadsto (T,\mu', \sigma_n, L)
%	}
%$
%\\
\\
\end{tabular}
\\
Note that the {\sf warp} rule only applies changes to the local configuration corresponding to the given transaction $t$. All other transactions retain their original local configurations.

\subsection{Formal Guarantees}

\begin{theorem}[Soundness] Any terminating execution of the transition system is guaranteed to yield a serializable shared log.
\begin{proof}
	The {\sf cmt} event acts as a gatekeeper, demanding that the log prefix including the outstanding events about to be committed is serializable. The check executes atomically together with the log update. Hence the system is guaranteed to terminate with a serializable shared log.	
\end{proof}
\end{theorem}

\begin{definition}[Progress]
	We say that the transition system has made progress, transitioning from (global) state $s$ to (global) state $s'$, if the associated event $e$ for
	$s \stackrel{e}{\longrightarrow} s'$ is either a ${\sf cmt}$ event or an ${\sf end}$ event.
\end{definition}

\begin{definition}[Progress-safe warping]
	Let ${\sf warp}\ t$ occur at system state $s=(T,\mu,\sigma,L)$, such that state $s'=(T,\mu[t \mapsto (c_t,\sigma_t,L_t)],\sigma,L)$ is reached. Assume that there is a reduction
	$(\sigma_t,c_t,L_t) {\longrightarrow} (\sigma'_t,c'_t,L'_t)$, such that 
	at system state $s''=(T,\mu[t \mapsto (\sigma'_t,c'_t,L'_t)],\sigma,L)$ either (i)  ${\sf cmt}\ t$ is enabled or (ii) ${\sf end}\ t$ is enabled. Then we refer to ${\sf warp}\ t$ at $s$ with target $(\sigma_t,c_t,L_t)$ as \emph{progress safe}.
\end{definition}

\begin{theorem}[Progress] Assume that (i) a ${\sf warp}\ t$ event only fires when a transaction $t$ reaches a commit point but fails to commit, and (ii) warping instances are progress safe. Then progress is guaranteed.
	\begin{proof}
	Given system state $s$, if there exists a transaction $t$ that is able to either commit or complete then the proof is done. Otherwise, there is a transaction $t$ that reaches a commit point at some state $s'$ and fails. At this point, ${\sf warp}\ t$ is the only enabled transition for $t$, and by assumption (ii), the warping instance is progress safe. At this point, there are two possibilities. Either $t$ proceeds without other threads modifying the shared state, such that a commit or completion point is reached by $t$ (without warping prior to reaching such a point according to assumption (i)), in which case progress has been achieved, or one or more threads interfere with $t$ by committing their effects, in which case too progress has been achieved.
	\end{proof}
\end{theorem}

An important observation (or relaxation) is that the local states of other threads are irrelevant to the success of a commit or end transition. Hence, the only cause of a failed commit is if other threads have committed.

\subsection{Other Stuff}

Events might be {\tt start}, {\tt read}, {\tt write}, {\tt warp}, {\tt commit}, {\tt abort}, and {\tt end}. Figure \ref{fi:semantics} formalizes the concrete semantics, where $a.b$ denotes the concatenation of sequence $a$ and sequence $b$, and $p_t$ represents the sequence of actions transaction $t$ performs.

\begin{figure*}
\begin{center}
\begin{tabular}{c}
\\
$\infer{\langle t, {\tt start}, (sh, tl, g, l)\rangle \to (sh, tl[t \mapsto (p_t, sh)], g, l[t \mapsto \epsilon])}{}$\\
\\
$\infer{\langle t, {\tt read}, (sh, tl, g, l)\rangle \to (sh, tl, g, l[t \mapsto l(t).{\tt read}])}{}$\\
\\
$\infer{\langle t, {\tt write}, (sh, tl, g, l)\rangle \to (sh, tl[t \mapsto \llbracket {\tt write}\rrbracket](tl(t)), g, l[t \mapsto l(t).{\tt write}])}{}$\\
\\
$\infer{\langle t, {\tt commit}, (sh, tl, g, l)\rangle \to (\llbracket l(t) \rrbracket(sh), tl, g.l(t), l\setminus [t \mapsto l(t)])}
{\textrm{if there is no conflict}}$\\
\\
$\infer{\langle t, {\tt commit}, (sh, tl, g, l)\rangle \to \langle t, {\tt warp}, (sh, tl, g, l)\rangle}
{\textrm{if there is a conflict}}$\\
\\
$\infer{\langle t, {\tt warp}, (sh, tl, g, l)\rangle \to (sh, tl[t \mapsto s], g, l[t \mapsto i])}
{\textrm{if the warping system produces state } s \textrm{ and  log } i}$\\
\\
$\infer{\langle t, {\tt end}, (sh, tl, g, l)\rangle \to (\llbracket l(t) \rrbracket(sh), tl \setminus [t \mapsto tl(t)], g.l(t), l\setminus [t \mapsto l(t)])}
{}$\\
\end{tabular}
\caption{Concrete semantics}
\label{fi:semantics}
\end{center}
\end{figure*}
