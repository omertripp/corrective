\newcommand{\set}[1]{\mathsf{#1}}
\newcommand{\isSummary}{\set{summary}}
\newcommand{\freshNode}{\set{fresh}}
\newcommand{\heapnode}{\set{HeapNode}}
\newcommand{\variable}{\set{Var}}
\newcommand{\env}{\set{Env}}
\newcommand{\map}{\set{Map}}
\newcommand{\state}{\set{\Sigma}}
\newcommand{\serializedCFGs}{\set{serializedCFGs}}
\newcommand{\iseqclass}{\set{eqClass}}
\newcommand{\warpdestination}{\set{warpDest}}

\section{Application to Composed Map Operations}
\label{se:instance}
As a proof of concept and study of practical feasibility, we instantiate the theoretical framework introduced in Section \ref{sec:concretesemantics} to a language comprising some basic operations on concurrent shared maps, and a restricted transaction system. In particular, we assume that (i) there are $n$ transactions ($T=\{t_1, ..., t_n\}$), (ii) all the transactions start together at the beginning of the execution, (iii) each transaction commit only once, and (iv) and all the transactions commit together at the end of the execution. Thanks to these assumptions, we can define a system that perform a \emph{global} warping at the end of the execution. While these restrictions might be relaxed, this scenario is particularly interesting in practice XXXX


\subsection{Language of Thread Local Operations}
\label{sect:language}

\begin{figure}[t]
	\begin{center}
		\begin{tabular}{l}
			\statement{s ::= m.put(k, v)}\\
			\hspace{15pt} \statement{|\ v=m.get(k)}\\
			\hspace{15pt} \statement{|\ m.remove(k)}\\
			\hspace{15pt} \statement{|\ v=m.putIfAbsent(k, v)}\\
			\hspace{15pt} \statement{|\ v=new\ Value()}\\
			\hspace{15pt} \statement{|\ v=null}\\
			\hspace{15pt} \statement{|\ assert(b)}\\
			%			\hspace{15pt} \statement{|\ if(b)\ s_1;\ else\ s_2}\\
			%			\hspace{15pt} \statement{|\ while(b)\ s_1;}\\
			%			\hspace{15pt} \statement{|\ s_1;\ s_2}\\
			\\
			\statement{b ::= x==null\ |\  x!=null}\\
			\hspace{15pt} \statement{|\ m.containsKey(k)\ |\ ! m.containsKey(k)}\\
		\end{tabular}
	\end{center}
	\caption{Fragment of the language dealing with map-related operations}
	\label{fig:language}
\end{figure}
We focus our formalization on the fragment of language in Figure \ref{fig:language}. This fragment is focused on a representative set  of operations of the Java \statement{java.util.concurrent.ConcurrentMap} class. We represent by \statement{m} the map shared among all the transactions, and \statement{k} a shared key. The values inserted or read from the map might be a parameter of the transaction, or created through a \statement{new} statement. Following the semantics of the Java library, our language supports (i) \statement{v=m.get(k)} that returns the value \statement{v} related with key \statement{k}, or \statement{null} if \statement{k} is not in the map, (ii) \statement{m.remove(k)} removes \statement{k} from the map, (iii) \statement{v=m.putIfAbsent(k, v)} relates \statement{k} to \statement{v} in \statement{m} if \statement{k} is already in \statement{m} and returns the previous value it was related to, (iv) \statement{v=new\ Value(...)} creates a new value, and (v) \statement{v=null} assigns \statement{null} to variable \statement{v}. In addition, our language supports a standard \statement{assert(b)} statement that let the execution go through iff the given Boolean condition holds. In particular, the language supports checking if a variable is \statement{null}, and if the map contains a key. This statement is adopted to support conditional and loop statements.


\subsubsection{Running Example}

\begin{figure}
\begin{lstlisting}
Value removeAttribute(Key k) {
  Value result = null;
  if(map.containsKey(k)) {
    result = m.get(k);
    m.remove(k);
  }
  return result;
}
	
boolean removeAttribute(Key k, Value v) {
  Value oldvalue = m.get(k);
  m.put(k, v);
  return oldvalue != null;
}
\end{lstlisting}
\caption{The running example inspired by class \statement{ApplicationContext} of Apache Tomcat}
\label{lst:runningexamplestaticanalysis}
\end{figure}

XXX Somewhere else? XXX

Figure \ref{lst:runningexamplestaticanalysis} illustrates our running example. This code is inspired by \pietrotodo{XXX}. The first type of transaction (\statement{transaction1}) removes the value associated with the given key \statement{k}, and returns it. Instead, the second type of transaction relates \statement{k} with a given value \statement{v}, and returns \statement{true} if the key was already in the map. During the formalization of the static analysis and the warping system, we will refer to this running example where each transaction is instantiated multiple times, and all transactions conflict on the same key \statement{k}.


\subsection{Static Computation of Warp Destinations}
Given a transaction $t$, the {\sf warp} rule of the transition system introduced in Section \ref{sec:transitionsystem} requires that the state the system warps to is reachable starting from the state at the beginning of the execution of $t$ (retrieved by ${\sf ref}\ t$) producing the same shared log. Since in our specific instance of the transition system we suppose that all the transactions start together, we assume that there is a unique entry state $s_0$. In addition, since all the transaction commit together at the end, we have complete control over the shared log XXX.

\subsubsection{Serialized Control Flow Graph}
\label{Se:concabs}
Before defining the abstract domain and semantics focused on composed map operations, we introduce a generic abstract transaction semantics, that, given $k$ types of transactions, computes the possible warping states starting from an entry state that represents a specific concrete situation. The possible warping states might be the result of the computation of several instances of the $k$ types of transactions. XXX

Let $\{c^1, ..., c^k\}$ be the code of $k$ different transactions. For each transaction type $i$, we create three static transaction identifiers $t^i_1$, $t^i_2$, and $t^i_n$. $t^i_1$ and $t^i_2$ represent precisely two concrete instances of $c^i$, while $t^i_n$ is a \emph{summary} abstract instance representing many concrete instances of $c^i$. We then build up a control flow graph representing a serialized execution of all these abstract transactions. In particular, each transaction type $c^i$ leads to a control flow graph $tc^i$ that executes (i) first $t^i_1$, (ii) then $t^i_n$ inside a non-deterministic loop (to overapproximate many instances of $c^i$)), and (iii) finally $t^i_2$. While the choice of having the two concrete transaction instances before and after the summary instance is arbitrary and other solutions are possible, we found this solution particularly effective in practice as we will show in Section \ref{Se:experiments}. The overall serialized program $tc$ is then build by concatenating the serialized CFGs of all transactions.


\subsubsection{Abstract Domain}
\label{sect:abstractate}

Let $\variable$ and $\heapnode$ be the set of variables and abstract heap nodes, respectively. We suppose that a special \statement{null} value is part of $\heapnode$. Both keys and values are abstracted as heap nodes. As usual with heap abstractions, each heap node might represent one or many concrete nodes. Therefore, we suppose that a function $\isSummary : \heapnode \to \{\true, \false\}$ is provided; $\isSummary(h)$ returns $\true$ if and only if $h$ represents many concrete nodes (that is, it is a summary node). We define by $\env : \variable \to \wp(\heapnode)$ the set of (abstract) environments relating each variable to the set of heap nodes it might point to. A map is represented as a function $\map : \heapnode \to \wp(\heapnode)$, connecting each key to the set of possible values it might be related to in the map. The value $\statement{null}$ represents that the key might not be in the map. For instance, $[n_1 \mapsto \{\statement{null}, n_2\}]$ represents that the key $n_1$ might not be in the map, or it is in the map, and it is related to value $n_2$. An abstract state is a pair made by an abstract environment and an abstract map. We augment this set with a special bottom value $\bot$ to will be used to represent that a statement is unreachable. Formally, $\state = (\env \times \map) \cup \{\bot\}$.

The lattice structure is obtained by the point-wise application of set operators to elements in the codomain of abstract environments and functions. Therefore, the abstract lattice is defined as $\langle \state, \dot{\subseteq}, \dot{\cup} \rangle$, where $\dot{\subseteq}$ and$\dot{\cup}$ represents the point-wise application of set operators $\subseteq$ and $\cup$, respectively.

\paragraph{Running example.} 
Consider the first method in Figure \ref{lst:runningexamplestaticanalysis}. For instance, the abstract state $([\statement{k} \mapsto \{n_1\}], [n_1 \mapsto \{\statement{null}\}])$ represents that the key \statement{key} is not in the map, while $([\statement{k} \mapsto \{n_1\}], [n_1 \mapsto \{n_2\}])$ represents that it is in the map, and it is related to a value. Instead, for the second method, $([\statement{k} \mapsto \{n_1\}, \statement{v} \mapsto n_2], [n_1 \mapsto \{n_2\}])$ represents that \statement{k} is in the map, and it is related to the value pointed by \statement{v}


\subsubsection{Abstract Semantics}
\label{sect:abstractsemantics}

\begin{figure*}
\[
\begin{array}{ll}
\csemantics{S}{\statement{m.put(k, v)}, (e, m)} = \left\{
\begin{array}{ll}
(e, m[n \mapsto e(\statement{v})]) & \textrm{if } e(\statement{k})=\{n\} \land \neg \isSummary(n)\\
(e, m[n \mapsto m(n) \cup e(\statement{v}) : n \in e(\statement{k})]) & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{put})\\
\\
\csemantics{S}{\statement{v=m.get(k)}, (e, m)} = (e[\statement{v} \mapsto \bigcup_{n \in e(k)} m(n)], m) & (\mathtt{get})\\
\\
\csemantics{S}{\statement{m.remove(k)}, (e, m)} =  \left\{
\begin{array}{ll}
(e, m[n \mapsto \{\statement{null}\}]) & \textrm{if } e(\statement{k})=\{n\} \land \neg \isSummary(n)\\
(e, m[n \mapsto m(n) \cup \{\statement{null}\} : n \in e(\statement{k})]) & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{rmv})\\ 
\\
\csemantics{S}{\statement{v = m.putIfAbsent(k, v)}, (e, m)} =  (\pi_1(\csemantics{S}{\statement{v = m.get(k)}, (e, m)}), m') : & \\
\hspace{70pt} 
m'=
\left\{
\begin{array}{ll}
(e, m[n \mapsto e(\statement{v})]) & \textrm{ if } e(\statement{k})=\{\statement{n}\} \land m(n) = \{\statement{null}\}\\
(e, m[n \mapsto m(n) \cup e(\statement{v}) : n \in e(\statement{k}) \land \statement{null} \in m(n)]) & \textrm{ otherwise}\\
\end{array}
\right. & (\mathtt{pIA})\\
\\
\csemantics{S}{\statement{v = new\ Value()}, (e, m)} =  (e[v \mapsto \freshNode(\statement{t})], m)& (\mathtt{new})\\
\\
\csemantics{S}{\statement{v = null}, (e, m)} =  (e[v \mapsto \{\statement{null}\}], m)& (\mathtt{null})\\
\\
%\csemantics{S}{\statement{if(b)\ s_1;\ else\ s_2}, (e, m)} =  \csemantics{S}{\statement{s_1}, \csemantics{B}{\statement{b}, (e, m)}} \dot{\cup} \csemantics{S}{\statement{s_2}, \csemantics{B}{\statement{! b}, (e, m)}} & \statement{(if)}\\
%\\
%\csemantics{S}{\statement{while(b)\ s_1;}, (e, m)} = \csemantics{B}{\statement{! b}, (e_1, m_1)} : 
%(e_1, m_1) = \mathit{lfp}^{\dot{\subseteq}}_{\bot} \lambda (e', m') . (e, m) \dot{\cup} \csemantics{S}{\statement{s_1}, \csemantics{B}{\statement{b}, (e', m')}}& \statement{(while)}\\
%\\
%\csemantics{S}{\statement{s_1;\ s_2}, (e, m)} =  \csemantics{S}{\statement{s_2}, \csemantics{S}{\statement{s_1}, (e, m)}} & \statement{(cnc)}\\
%\\
\csemantics{S}{\statement{assert(x==null)}, (e, m)} = \left\{
\begin{array}{ll}
(e[\statement{x} \mapsto \{\statement{null}\}], m) & \textrm{if } \statement{null} \in e(\statement{x})\\
\bot & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{null})\\
\\
\csemantics{S}{\statement{assert(x!=null)}, (e, m)} = \left\{
\begin{array}{ll}
(e[\statement{x} \mapsto e(\statement{x}) \setminus \{\statement{null}\}], m) & \textrm{if } \exists n \in \heapnode : n \neq \statement{null} \land n \in e(\statement{x})\\
\bot & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{!null})\\
\\
\csemantics{S}{\statement{assert(m.containsKey(k))}, (e, m)} = \left\{
\begin{array}{ll}
\bot & \textrm{if } \forall n \in e(\statement{k}) : m(n)=\{\statement{null}\}\\
(e, m[n \mapsto m(n)\setminus\{\statement{null}\}]) & \textrm{if } e(\statement{k}) = \{n\} \land \neq \isSummary(n) \land m(n) \neq \{\statement{null}\}\\
(e, m) & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{cntK})\\
\\
\csemantics{S}{\statement{assert(!m.containsKey(k))}, (e, m)} = \left\{
\begin{array}{ll}
\bot & \textrm{if } \forall n \in e(\statement{k}) : \statement{null} \notin m(n)\\
(e, m[n \mapsto \{\statement{null}\}) & \textrm{if } e(\statement{k}) = \{n\} \land \neq \isSummary(n) \land \statement{null} \in m(n)\\
(e, m) & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{!cntK})\\
\end{array}
\]
\caption{Formal definition of the abstract semantics}
\label{fig:abstractsemantics}
\end{figure*}
Figure \ref{fig:abstractsemantics} formalizes the abstract semantics of statements and Boolean conditions, that, given an abstract state (as defined in Section \ref{sect:abstractate}) and a statement or Boolean condition of the language introduced in Section \ref{sect:language}, returns the abstract state resulting from the evaluation of the given statement on the given abstract state. We focus the formalization on abstract states in $\env \times \map$, since in case of $\bot$ the abstract semantics always returns $\bot$ itself.

\statement{(put)} relates \statement{k} to \statement{v} in the map. In particular, if \statement{k} points to a unique concrete node, it performs a so-called strong update, overwriting previous values related with \statement{k}. Otherwise, it performs a weak update by adding to the previous values the new ones. \statement{(get)} relates the assigned variable \statement{v} to all the heap nodes of values that might be related with \statement{k} in the map. Note that if \statement{k} is not in the map, then the abstract map $m$ relates it to a \statement{null} node, and therefore this value is propagated to \statement{v} then calling \statement{get}, representing the concrete semantics of this statement. Similarly to \statement{(put)}, \statement{(rmv)} removes \statement{k} from the map (by relating it to the singleton $\{\statement{null}\}$) iff \statement{k} points to a unique concrete node. Otherwise, it adds the heap node \statement{null} to the heap nodes related to all the values pointed by \statement{k}. \statement{(pIA)} updates the map like \statement{(put)} but only if the updated key node might have been absent, that is, when $\statement{null} \in m(n)$. \statement{new} creates a new heap node through $\freshNode(t)$ (where $t$ is the identifier of the transaction performing the creation), and assigns it to \statement{v}. The number of nodes is kept bounded by parameterizing the analysis with an upper bound $i$ such that (i) the first $i$ nodes created by a transaction are all concrete nodes, and (ii) all the other nodes are represented by a summary node. Instead, \statement{(null)} relates the given variable to the singleton $\{\statement{null}\}$.
The abstract semantics on Boolean conditions produces $\bot$ statements if the given Boolean condition cannot hold on the given abstract semantics. Therefore, \statement{(null)} returns $\bot$ if the given variable \statement{x} cannot be \statement{null}, or a state relating \statement{x} to the singleton $\{\statement{null}\}$ otherwise. Vice-versa, \statement{(!null)} returns $\bot$ if \statement{x} can be only null, or a state relating \statement{x} to all its previous values except \statement{null} otherwise.
Similarly, \statement{(cntK)} returns $\bot$ if the given key \statement{k} is surely not in the map, it refines the possible values of \statement{k} if it is represented by a concrete node, or it simply returns the entry state otherwise. Vice-versa, \statement{(!cntK)} returns $\bot$ if \statement{k} is surely in the map.

\paragraph{Running example.}
Consider again the first method in Figure \ref{lst:runningexamplestaticanalysis}. When we start from the abstract state  $([\statement{k} \mapsto \{n_1\}], [n_1 \mapsto \{\statement{null}\}])$ (representing that \statement{k} is not in the map), we obtain the abstract state $\sigma = ([\statement{k} \mapsto \{n_1\}, \statement{result} \mapsto \{null\}], [n_1 \mapsto \{\statement{null}\}])$ after the first statement by rule \statement{(null)}. During the following computation of rule \statement{(if)}, we consider:
\begin{enumerate}
	\item when the Boolean condition \statement{map.containsKey(k)} holds. When applying rule \statement{(cntK)} on $\sigma$ we obtain $\bot$ since the node pointed by \statement{k} is related to the singleton $\{\statement{null}\}$ in the map, representing that the map does not contain the key \statement{k}; and
	\item when \statement{! map.containsKey(k)} holds. Rule \statement{(!cntK)} applied to $\sigma$ returns $\sigma$ itself, since \statement{k} is in relation only with \statement{null} in the map.
\end{enumerate}
\statement{(if)} returns the upper bound of the two resulting states, that is $\bot \dot{\cup} \sigma = \sigma$, and the value pointed by \statement{result} (that is, \statement{null}) is returned.
Therefore, our analysis computes on this example that, when the key is not in the map in the entry state, the method returns \statement{null} and does not modify the map.

\subsubsection{Extracting Possible Warping States}
\pietrotodo{I jump directly into equivalence classes, need to reason about this before!!!}

We need now to compute possible warping targets on the serialized control flow graph $tc$ (as defined in \ref{Se:concabs}) using the abstract semantics $\semanticanome{S}$. In particular, we need to compute warping that, given an entry state representing an observational equivalence class, is in an equivalence class that is reachable through a serialized execution. However, an abstract state in $\state$ might represent concrete states that are in different equivalence classes. For instance $([\statement{k} \mapsto \{n_1\}], [n_1 \mapsto \{\statement{null}, n_2\}])$ represents both that  \statement{k} is (if $n_1$ is related to $n_2$ in the abstract map) or is not (when $n_1$ is related to $\statement{null}$). This abstract state therefore might concretize to states belonging to different equivalence classes, and it cannot used to define a warping destination.

Therefore, we define a predicate $\iseqclass : \state \to \{\true, \false\}$ that, given an abstract state, holds iff it represents concrete states all in the same equivalence class. Formally,
\[
\begin{array}{c}
\iseqclass(e, m)\\
\Updownarrow\\
\forall \statement{x} \in \dom{e} : |e(\statement{x})|=1 \land e(\statement{x})=\{n_1\} \land \neg \isSummary(n_1)\\
\forall n \in \dom{m} : |m(n)|=1 \land m(n)=\{n_2\} \land \neg \isSummary(n_2)\\
\end{array}
\]
\pietrotodo{Prove that if $\iseqclass(e,m)$ then all the concretized states from $(e, m)$ are in the same equivalence class}


Given two transactions \statement{t1} and \statement{t2}, we build up a set of possible entry states $S$ such that $\forall (e, m) \in S : \iseqclass(e, m)$. We then compute the exit states for all the possible serialized CFGs and entry states, and we filter our only the ones that represents states in the same equivalence class. The results are represented as a function that relates each entry state to a set of possible exit states. This is formalized by the following $\warpdestination$ function.


\[
\begin{array}{l}
\warpdestination(\statement{t1}, \statement{t2}, \set{S}) =\{(e', m'):\\
\hspace{10pt} \exists (e, m) \in \set{S}, \exists \statement{s} \in \serializedCFGs(\statement{t1}, \statement{t2}) :\\
\hspace{20pt} (e', m') \in \csemantics{S}{\statement{s}, (e, m)} \land \iseqclass(e', m')\}\\
\end{array}
\]

\pietrotodo{Not yet explained how we compute the possible entry states}

\newcommand\ts{\bar{t}}

%
%\subsection{Concrete state}
%Let $\Sigma = \gamma(\Ts \times G)$ be the concrete states, denoted $\sigma = (\ts,g)$.
%
%\newcommand\Pietrot{{\cal P}ietro}
%
%Discover a $\Pietrot : \hat{\Sigma} \rightarrow \hat{\Sigma}
%\rightarrow \wp({\hat{\Sigma}})$, representing the current abstract
%state, the reference abstract state, and a set of possible destination
%abstract states.


\subsection{Dynamic Warping}

%\section{Dynamic Warping}
%
%\newcommand\Pengt{{\cal P}eng}
%Given $\Pietrot$, the runtime system implements a function
%denoted $\Pengt : \sigma \rightarrow \hat{\sigma} \rightarrow \hat{\sigma} \rightarrow \sigma$. 
%
%
%Runtime tracks the current concrete state $\sigma$,
%current \emph{abstract state} $\hat{\sigma}$ and the last
%\emph{abstract reference state} $\hat{\sigma}_0$. Thus, we denote the runtime
%configuration as
%$$
%c =  \llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle 
%\;\;\;\text{ or, expanding }
%\llangle (\ts,g),(\Ts,G),(\Ts_0,G_0) \rrangle 
%$$
%That is, threads are in state $\ts$, shared state $g$, tracked abstract state
%$(\Ts,G)$ and tracked abstract reference state $(\Ts_0,G_0)$.
%
%There are then the following rules for steps in the runtime system:
%
%$$
%\infer=[\text{\bf Diverge}]{
%	\llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle 
%	\hookrightarrow^{*}
%	\llangle \sigma',\hat{\sigma}',\hat{\sigma}_0 \rrangle 
%}{ ... }
%$$
%
%
%$$
%\infer=[\text{\bf Warp}]{
%	\llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle
%	\hookrightarrow
%	\llangle \sigma',\hat{\sigma}',\hat{\sigma}_0 \rrangle
%}{
%\hat{\sigma}' \in \Pietrot(\hat{\sigma}_0,\red{\hat{\sigma}})
%& \sigma' = \Pengt(\sigma,\hat{\sigma},\hat{\sigma}')
%}
%$$
%
%$$
%\infer=[\text{\bf Commit}]{
%	\llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle
%	\hookrightarrow
%	\llangle \sigma',\hat{\sigma}',\hat{\sigma}' \rrangle
%}{ ... }
%$$
%
%$$
%\infer=[\text{\bf Step}]{
%	\llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle
%	\hookrightarrow
%	\llangle \sigma',\hat{\sigma}',\hat{\sigma}_0 \rrangle
%}{
%\red{fix}
%g \in \gamma(G)
%& \Ts,G \xrightarrow{P\! P} \Ts',G'
%& g' \in \gamma(G')}
%$$
%
%$\Pietrot$ ensures that $\hat{\sigma}'$ is reachable from $\hat{\sigma}_0$.
%
%$\Pengt$ ensures that $\sigma\in\gamma{\hat{\sigma}}$
%and that you awlays warp before you commit (or you always eventually
%warp)
