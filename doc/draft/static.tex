\newcommand{\set}[1]{\mathsf{#1}}
\newcommand{\isSummary}{\set{isSummary}}
\newcommand{\freshNode}{\set{fresh}}
\newcommand{\heapnode}{\set{HeapNode}}
\newcommand{\reference}{\set{Ref}}
\newcommand{\variable}{\set{Var}}
\newcommand{\env}{\set{Env}}
\newcommand{\map}{\set{Map}}
\newcommand{\aset}[1]{\set{#1}^\#}
\newcommand{\state}{\set{\Sigma}}
\newcommand{\aenv}{\aset{Env}}
\newcommand{\amap}{\aset{Map}}
\newcommand{\astate}{\aset{\Sigma}}
\newcommand{\multistate}{\set{\Phi}}
\newcommand{\amultistate}{\aset{\multistate}}
\newcommand{\serializedCFGs}{\set{serializedCFGs}}
\newcommand{\isconcrete}{\set{single}}
\newcommand{\warpdestination}{\set{warpDest}}
\newcommand{\concretetransactions}{\set{TId}}
\newcommand{\abstracttransactions}{\aset{\concretetransactions}}

\section{Thread Local Semantics}
\label{se:instance}
We now instantiate the theoretical framework introduced in Section \ref{sec:concretesemantics} to a language supporting some standard operations on concurrent shared maps. In this Section, we define the thread-local concrete semantics of this language. This instantiates the {\sf local} rule introduced in Section \ref{sec:transitionsystem}. Following the abstract interpretation theory, we then introduce an abstract domain and semantics that computes an approximation of the concrete semantics. This thread-local abstract semantics will be used in Section \ref{sec:transactionsystemwarping} to compute progress-safe warping destinations.


\subsection{Language}
\label{sect:language}

\begin{figure}[t]
	\begin{center}
		\begin{tabular}{l}
			\statement{s ::= m.put(k, v)}\\
			\hspace{15pt} \statement{|\ v=m.get(k)}\\
			\hspace{15pt} \statement{|\ m.remove(k)}\\
			\hspace{15pt} \statement{|\ v=m.putIfAbsent(k, v)}\\
			\hspace{15pt} \statement{|\ v=new\ Value()}\\
			\hspace{15pt} \statement{|\ v=null}\\
			\hspace{15pt} \statement{|\ assert(b)}\\
			%			\hspace{15pt} \statement{|\ if(b)\ s_1;\ else\ s_2}\\
			%			\hspace{15pt} \statement{|\ while(b)\ s_1;}\\
			%			\hspace{15pt} \statement{|\ s_1;\ s_2}\\
			\\
			\statement{b ::= x==null\ |\  x!=null}\\
			\hspace{15pt} \statement{|\ m.containsKey(k)\ |\ ! m.containsKey(k)}\\
		\end{tabular}
	\end{center}
	\caption{Fragment of the language dealing with map-related operations}
	\label{fig:language}
\end{figure}
We focus our formalization on the fragment of language in Figure \ref{fig:language}. This fragment is focused on a representative set  of operations of the Java \statement{java.util.concurrent.ConcurrentMap} class XXX Add API's URL XXX. We represent by \statement{m} the map shared among all the transactions, and \statement{k} a shared key. The values inserted or read from the map might be a parameter of the transaction, or created through a \statement{new} statement. Following the semantics of the Java library, our language supports (i) \statement{v=m.get(k)} that returns the value \statement{v} related with key \statement{k}, or \statement{null} if \statement{k} is not in the map, (ii) \statement{m.remove(k)} removes \statement{k} from the map, (iii) \statement{v=m.putIfAbsent(k, v)} relates \statement{k} to \statement{v} in \statement{m} if \statement{k} is already in \statement{m} and returns the previous value it was related to, (iv) \statement{v=new\ Value(...)} creates a new value, and (v) \statement{v=null} assigns \statement{null} to variable \statement{v}. In addition, our language supports a standard \statement{assert(b)} statement that let the execution go through iff the given Boolean condition holds. In particular, the language supports checking if a variable is \statement{null}, and if the map contains a key. This statement is necessary to support conditional and loop statements.


\subsubsection{Running Example}

\begin{figure}
\begin{lstlisting}
Value removeAttribute(Key k) {
  Value result = null;
  if(map.containsKey(k)) {
    result = m.get(k);
    m.remove(k);
  }
  return result;
}
	
boolean removeAttribute(Key k, Value v) {
  Value oldvalue = m.get(k);
  m.put(k, v);
  return oldvalue != null;
}
\end{lstlisting}
\caption{The running example inspired by class \statement{ApplicationContext} of Apache Tomcat}
\label{lst:runningexamplestaticanalysis}
\end{figure}

XXX Somewhere else? XXX

Figure \ref{lst:runningexamplestaticanalysis} illustrates our running example. This code is inspired by \pietrotodo{XXX}. The first type of transaction (\statement{transaction1}) removes the value associated with the given key \statement{k}, and returns it. Instead, the second type of transaction relates \statement{k} with a given value \statement{v}, and returns \statement{true} if the key was already in the map. During the formalization of the static analysis and the warping system, we will refer to this running example where each transaction is instantiated multiple times, and all transactions conflict on the same key \statement{k}.


\subsection{Concrete Domain and Semantics}
\label{sec:concretemap}
First of all, we instantiate the local state and log of a transaction $t$ introduced in \ref{sec:concretedomain} to the language of Section \ref{sect:language}.

Let $\variable$ and $\reference$ be the set of variables and references, respectively. Keys and values are identified by concrete references, and we assume $\statement{null}$ is in $\reference$. We define by $\env : \variable \to \reference$ the environments relating local variables to references. A map is then represented as a function $\map : \reference \to \reference$, relating keys to values. The value $\statement{null}$ represents that the related key is not in the map. A single concrete state is a pair made by an environment and a map. Formally, $\state = \env \times \map$. As usual in abstract interpretation, we collect a set of states per program point. Therefore, our concrete domain is made by elements in $\wp(\state)$, and the lattice relies on standard set operators. Formally, $\langle \wp(\state), \subseteq, \cup \rangle$.

In addition to the local state, the concrete domain tracks the log of operations. Given the language defined in Section \ref{sect:language}, the operations tracked in the concrete log are $\statement{put}(r_k, r_v)$ and $\statement{remove}(r_k)$ where $r_k, r_v \in \reference$.

We do not provide the complete formalization of the concrete semantics since it is the straightforward definition of map operations over the concrete domain. Note that \statement{putIfAbsent} creates an entry $\statement{put}$ iff the key is not yet in the map. XXX Add the concrete semantics to an appendix? XXX

\subsection{Abstract Domain}
\label{sect:abstractate}

Let $\heapnode$ be the set of abstract heap nodes with $\statement{null} \in \heapnode$. Both keys and values are abstracted as heap nodes. As usual with heap abstractions, each heap node might represent one or many concrete references. Therefore, we suppose that a function $\isSummary : \heapnode \to \{\true, \false\}$ is provided; $\isSummary(h)$ returns $\true$ if and only if $h$ represents many concrete nodes (that is, it is a summary node). We define by $\aenv : \variable \to \wp(\heapnode)$ the set of (abstract) environments relating each variable to the set of heap nodes it might point to. A map is represented as a function $\amap : \heapnode \to \wp(\heapnode)$, connecting each key to the set of possible values it might be related to in the map. The value $\statement{null}$ represents that the key is not in the map. For instance, $[n_1 \mapsto \{\statement{null}, n_2\}]$ represents that the key $n_1$ might not be in the map, or it is in the map, and it is related to value $n_2$. An abstract state is a pair made by an abstract environment and an abstract map. We augment this set with a special bottom value $\bot$ to will be used to represent that a statement is unreachable. Formally, $\astate = (\aenv \times \amap) \cup \{\bot\}$.

The lattice structure is obtained by the point-wise application of set operators to elements in the codomain of abstract environments and functions. Therefore, the abstract lattice is defined as $\langle \astate, \dot{\subseteq}, \dot{\cup} \rangle$, where $\dot{\subseteq}$ and$\dot{\cup}$ represents the point-wise application of set operators $\subseteq$ and $\cup$, respectively.

For the sake of simplicity, we omit in the formalization the local log in the abstract domain. The only difference w.r.t. the concrete local log is that the entries refer to abstract heap nodes in $\heapnode$ instead of concrete references in $\reference$, and the presences of the entry \statement{?put} representing a possible \statement{put} action. This will be used in the definition of the abstract semantics of statement \statement{putIfAbsent}. XXX We can formalize the log. However, the problem is that the sequence might be infinite, so we need some kind of regular expressions - not sure I'm willing to go into this direction XXX 

\paragraph{Running example.} 
Consider the first method in Figure \ref{lst:runningexamplestaticanalysis}. For instance, the abstract state $([\statement{k} \mapsto \{n_1\}], [n_1 \mapsto \{\statement{null}\}])$ represents that the key \statement{key} is not in the map, while $([\statement{k} \mapsto \{n_1\}], [n_1 \mapsto \{n_2\}])$ represents that it is in the map, and it is related to a value. Instead, for the second method, $([\statement{k} \mapsto \{n_1\}, \statement{v} \mapsto n_2], [n_1 \mapsto \{n_2\}])$ represents that \statement{k} is in the map, and it is related to the value pointed by \statement{v}

\subsection{Concretization function.}
We define the concretization function $\gamma_\state : \astate \to \wp(\state)$ that, given an abstract state, returns the set of concrete states it represents. First of all, we assume that a function concretizing abstract heap nodes to concrete references is given. Formally, $\gamma_\reference : \heapnode \to \wp(\reference)$. We assume that this concretization function concretizes \statement{null} into itself ($\gamma_\reference(\statement{null})=\{\statement{null}\}$), and that it is coherent w.r.t. the information provided by $\isSummary$ ($\neg \isSummary(n) \Leftrightarrow |\gamma_\reference(n)|=1$).

The concretization function of abstract environments relates each variable in the environment to one of the references concretized from the node it is in relation with. Similarly, the concretization of abstract maps relate a reference concretized from a heap node representing a key with a reference concretized from a node representing a value. Finally, the concretization of abstract states is the pointwise application of the concretization of environments and maps. This is formalized as follows:
\[
\begin{array}{l}
\gamma_\env(e) = \{\lambda x . r : x \in \dom{e} \land \exists n \in e(x) : r \in \gamma_\reference(n)\}\\
\gamma_\map(m) = \{\lambda r_1 . r_2 : \exists n_1 \in \dom{m} : r_1 \in \gamma_\reference(n_1) \land\\
\hspace{100pt} \exists n_2 \in m(n_1) : r_2 \in \gamma_\reference(n_2) \}\\
\gamma_\state(e, m) = \{(e', m') : e' \in \gamma_\env(e) \land m' \in \gamma_\map(m)\}\\
\end{array}
\]

The concretization of local logs simply relies on $\gamma_\reference$ to concretizes abstract heap nodes into concrete references, and it produces traces where a \statement{put} entry is or is not present when concretizing the abstract entry \statement{?put}.

\begin{lemma}[Soundness of the domain]
	The abstract domain is a sound approximation of the concrete domain, that is, they form a Galois connection \cite{CC77}. Formally, $\langle \wp(\state), \subseteq, \cup \rangle \galois{\alpha_\state}{\gamma_\state} \langle \astate, \dot{\subseteq}, \dot{\cup} \rangle$ where $\alpha_\state = \lambda \cset{X} . \cap \{\cset{Y} : \cset{Y} \subseteq \gamma_\state(X)\}$.
\end{lemma}

\paragraph{Running example:} XXX



\subsection{Abstract Semantics}
\label{sect:abstractsemantics}

\begin{figure*}
\[
\begin{array}{ll}
\csemantics{S}{\statement{m.put(k, v)}, (e, m)} = \left\{
\begin{array}{ll}
(e, m[n \mapsto e(\statement{v})]) & \textrm{if } e(\statement{k})=\{n\} \land \neg \isSummary(n)\\
(e, m[n \mapsto m(n) \cup e(\statement{v}) : n \in e(\statement{k})]) & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{put})\\
\\
\csemantics{S}{\statement{v=m.get(k)}, (e, m)} = (e[\statement{v} \mapsto \bigcup_{n \in e(k)} m(n)], m) & (\mathtt{get})\\
\\
\csemantics{S}{\statement{m.remove(k)}, (e, m)} =  \left\{
\begin{array}{ll}
(e, m[n \mapsto \{\statement{null}\}]) & \textrm{if } e(\statement{k})=\{n\} \land \neg \isSummary(n)\\
(e, m[n \mapsto m(n) \cup \{\statement{null}\} : n \in e(\statement{k})]) & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{rmv})\\ 
\\
\csemantics{S}{\statement{v = m.putIfAbsent(k, v)}, (e, m)} =  (\pi_1(\csemantics{S}{\statement{v = m.get(k)}, (e, m)}), m') : & \\
\hspace{70pt} 
m'=
\left\{
\begin{array}{ll}
(e, m[n \mapsto e(\statement{v})]) & \textrm{ if } e(\statement{k})=\{\statement{n}\} \land m(n) = \{\statement{null}\}\\
(e, m[n \mapsto m(n) \cup e(\statement{v}) : n \in e(\statement{k})]) & \textrm{ if } \statement{null} \in m(n) \land |m(n)| > 1\\
(e, m) & \textrm{ otherwise}\\
\end{array}
\right. & (\mathtt{pIA})\\
\\
\csemantics{S}{\statement{v = new\ Value()}, (e, m)} =  (e[v \mapsto \freshNode(\statement{t})], m)& (\mathtt{new})\\
\\
\csemantics{S}{\statement{v = null}, (e, m)} =  (e[v \mapsto \{\statement{null}\}], m)& (\mathtt{null})\\
\\
%\csemantics{S}{\statement{if(b)\ s_1;\ else\ s_2}, (e, m)} =  \csemantics{S}{\statement{s_1}, \csemantics{B}{\statement{b}, (e, m)}} \dot{\cup} \csemantics{S}{\statement{s_2}, \csemantics{B}{\statement{! b}, (e, m)}} & \statement{(if)}\\
%\\
%\csemantics{S}{\statement{while(b)\ s_1;}, (e, m)} = \csemantics{B}{\statement{! b}, (e_1, m_1)} : 
%(e_1, m_1) = \mathit{lfp}^{\dot{\subseteq}}_{\bot} \lambda (e', m') . (e, m) \dot{\cup} \csemantics{S}{\statement{s_1}, \csemantics{B}{\statement{b}, (e', m')}}& \statement{(while)}\\
%\\
%\csemantics{S}{\statement{s_1;\ s_2}, (e, m)} =  \csemantics{S}{\statement{s_2}, \csemantics{S}{\statement{s_1}, (e, m)}} & \statement{(cnc)}\\
%\\
\csemantics{S}{\statement{assert(x==null)}, (e, m)} = \left\{
\begin{array}{ll}
(e[\statement{x} \mapsto \{\statement{null}\}], m) & \textrm{if } \statement{null} \in e(\statement{x})\\
\bot & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{null})\\
\\
\csemantics{S}{\statement{assert(x!=null)}, (e, m)} = \left\{
\begin{array}{ll}
(e[\statement{x} \mapsto e(\statement{x}) \setminus \{\statement{null}\}], m) & \textrm{if } \exists n \in \heapnode : n \neq \statement{null} \land n \in e(\statement{x})\\
\bot & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{!null})\\
\\
\csemantics{S}{\statement{assert(m.containsKey(k))}, (e, m)} = \left\{
\begin{array}{ll}
\bot & \textrm{if } \forall n \in e(\statement{k}) : m(n)=\{\statement{null}\}\\
(e, m[n \mapsto m(n)\setminus\{\statement{null}\}]) & \textrm{if } e(\statement{k}) = \{n\} \land \neq \isSummary(n) \land m(n) \neq \{\statement{null}\}\\
(e, m) & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{cntK})\\
\\
\csemantics{S}{\statement{assert(!m.containsKey(k))}, (e, m)} = \left\{
\begin{array}{ll}
\bot & \textrm{if } \forall n \in e(\statement{k}) : \statement{null} \notin m(n)\\
(e, m[n \mapsto \{\statement{null}\}) & \textrm{if } e(\statement{k}) = \{n\} \land \neq \isSummary(n) \land \statement{null} \in m(n)\\
(e, m) & \textrm{otherwise}\\
\end{array}
\right. & (\mathtt{!cntK})\\
\end{array}
\]
\caption{Formal definition of the abstract semantics}
\label{fig:abstractsemantics}
\end{figure*}
Figure \ref{fig:abstractsemantics} formalizes the abstract semantics of statements and Boolean conditions, that, given an abstract state (as defined in Section \ref{sect:abstractate}) and a statement or Boolean condition of the language introduced in Section \ref{sect:language}, returns the abstract state resulting from the evaluation of the given statement on the given abstract state. We focus the formalization on abstract states in $\aenv \times \amap$, since in case of $\bot$ the abstract semantics always returns $\bot$ itself.

\statement{(put)} relates \statement{k} to \statement{v} in the map. In particular, if \statement{k} points to a unique non-summary node, it performs a so-called strong update, overwriting previous values related with \statement{k}. Otherwise, it performs a weak update by adding to the previous values the new ones. \statement{(get)} relates the assigned variable \statement{v} to all the heap nodes of values that might be related with \statement{k} in the map. Note that if \statement{k} is not in the map, then the abstract map $m$ relates it to a \statement{null} node, and therefore this value is propagated to \statement{v} then calling \statement{get}, representing the concrete semantics of this statement. Similarly to \statement{(put)}, \statement{(rmv)} removes \statement{k} from the map (by relating it to the singleton $\{\statement{null}\}$) iff \statement{k} points to a unique concrete node. Otherwise, it conservatively adds the heap node \statement{null} to the heap nodes related to all the values pointed by \statement{k}. \statement{(pIA)} updates the map like \statement{(put)} but only if the updated key node might have been absent, that is, when $\statement{null} \in m(n)$. \statement{new} creates a new heap node through $\freshNode(t)$ (where $t$ is the identifier of the transaction performing the creation), and assigns it to \statement{v}. The number of nodes is kept bounded by parameterizing the analysis with an upper bound $i$ such that (i) the first $i$ nodes created by a transaction are all concrete nodes, and (ii) all the other nodes are represented by a summary node. Instead, \statement{(null)} relates the given variable to the singleton $\{\statement{null}\}$.
The abstract semantics on Boolean conditions produces $\bot$ statements if the given Boolean condition cannot hold on the given abstract semantics. Therefore, \statement{(null)} returns $\bot$ if the given variable \statement{x} cannot be \statement{null}, or a state relating \statement{x} to the singleton $\{\statement{null}\}$ otherwise. Vice-versa, \statement{(!null)} returns $\bot$ if \statement{x} can be only null, or a state relating \statement{x} to all its previous values except \statement{null} otherwise.
Similarly, \statement{(cntK)} returns $\bot$ if the given key \statement{k} is surely not in the map, it refines the possible values of \statement{k} if it is represented by a concrete node, or it simply returns the entry state otherwise. Vice-versa, \statement{(!cntK)} returns $\bot$ if \statement{k} is surely in the map.

For the sake of simplicity, we omit in the formalization of the abstract semantics the local log. Intuitively, the abstract semantics of \statement{put} produces a \statement{put} entry, \statement{remove} a \statement{remove} entry, while \statement{putIfAbsent} produces \statement{put} in the first case of the definition of $m'$ of rule \statement{(pIA)}, \statement{?put} in the second case, and nothing in the third case.


\begin{lemma}[Soundness of the semantics]
	The abstract semantics is a sound approximation of the concrete semantics. Formally, $\forall \statement{st}, (e, m) \in \astate: \gamma_\state(\csemantics{S}{\statement{st}, (e, m)}) \supseteq \csemantics{C}{\statement{st}, \gamma_\state(e, m)}$, where $\semanticanome{C}$ represents the pointwise application of the concrete semantics introduced in Section \ref{sec:concretemap} to a set of concrete states.
\end{lemma}
\begin{proof}
TODO
\end{proof}

\paragraph{Running example.}
Consider again the first method in Figure \ref{lst:runningexamplestaticanalysis}. When we start from the abstract state  $([\statement{k} \mapsto \{n_1\}], [n_1 \mapsto \{\statement{null}\}])$ (representing that \statement{k} is not in the map), we obtain the abstract state $\sigma = ([\statement{k} \mapsto \{n_1\}, \statement{result} \mapsto \{null\}], [n_1 \mapsto \{\statement{null}\}])$ after the first statement by rule \statement{(null)}. During the following computation of rule \statement{(if)}, we consider:
\begin{enumerate}
	\item when the Boolean condition \statement{map.containsKey(k)} holds. When applying rule \statement{(cntK)} on $\sigma$ we obtain $\bot$ since the node pointed by \statement{k} is related to the singleton $\{\statement{null}\}$ in the map, representing that the map does not contain the key \statement{k}; and
	\item when \statement{! map.containsKey(k)} holds. Rule \statement{(!cntK)} applied to $\sigma$ returns $\sigma$ itself, since \statement{k} is in relation only with \statement{null} in the map.
\end{enumerate}
\statement{(if)} returns the upper bound of the two resulting states, that is $\bot \dot{\cup} \sigma = \sigma$, and the value pointed by \statement{result} (that is, \statement{null}) is returned.
Therefore, our analysis computes on this example that, when the key is not in the map in the entry state, the method returns \statement{null} and does not modify the map.


\section{Transaction System Semantics}
\label{sec:transactionsystemwarping}
In this Section, we apply the local abstract semantics defined in Section \ref{sect:abstractsemantics} to infer warping destinations.

In our approach, we support a restricted transactional model. In particular, we assume that there are $n$ transactions that start the execution together at the beginning of the execution, each transaction commit only once, and and all the transactions commit together at the end of the execution. Thanks to these assumptions, we can define a system that perform a \emph{global} warping at the end of the execution. While these restrictions might be relaxed, this scenario is particularly interesting in practice XXX


\subsection{Serialized Control Flow Graph}
\label{Se:concabs}
We apply the abstract semantics defined in Section \ref{sect:abstractsemantics} to compute suitable warping targets. In particular, we need that these targets are reachable from the same \emph{entry state} through a \emph{serializable execution}. Therefore, we build up a control flow graph that represents some specific \emph{serialized} executions. In particular, we assume that we have $k$ distinct types of transactions, and we build up a serialized CFG that represents a serialized execution of \emph{at least} 2 instances of each type of transactions.

Let $\{c^1, ..., c^k\}$ be the code of $k$ different transactions. For each transaction type $i$, we create three static transaction identifiers $t^i_1$, $t^i_2$, and $t^i_n$. $t^i_1$ and $t^i_2$ represent precisely two concrete instances of $c^i$, while $t^i_n$ is a \emph{summary} abstract instance representing many concrete instances of $c^i$. We then build up a control flow graph representing a serialized execution of all these abstract transactions. In particular, each transaction type $c^i$ leads to a control flow graph $tc^i$ that executes (i) first $t^i_1$, (ii) then $t^i_n$ inside a non-deterministic loop (to overapproximate many instances of $c^i$)), and (iii) finally $t^i_2$. While the choice of having the two concrete transaction instances before and after the summary instance is arbitrary and other solutions are possible, we found this solution particularly effective in practice as we will show in Section \ref{Se:experiments}. The overall serialized CFG $tc$ is then built by concatenating the CFGs of all these transactions.

Note that we apply the abstract semantics to the various transactions, and we build a function that for each transaction $t^i_j$ tracks its local state and log. Let $\abstracttransactions$ be the set of abstract transactions, that is $\abstracttransactions = \{t^i_j : i \in [1..k], j \in \{1, 2, n\}\}$. Then our semantics on a serialized control flow graph returns a function in $\amultistate : \abstracttransactions \to \astate$.

XXX This should be inside the explanations about the running example XXX We suppose that all the transactions conflict on the same key. For instance, in the example in Figure \ref{lst:runningexamplestaticanalysis} we suppose that the parameter \statement{key} is the same for all the instances of both types of transactions. Instead, each instance of the second type has a different value parameter \statement{v}.
	

\subsection{Extracting Possible Warping States}
First of all, notice that, given a transaction $t$, the {\sf warp} rule of the transition system introduced in Section \ref{sec:transitionsystem} requires that the state the system warps to is reachable starting from the state at the beginning of the execution of $t$ (retrieved by ${\sf ref}\ t$) producing the same shared log (formally, ${\sf ref}\ t \leadsto (T,\mu', \sigma, L)$). Since in our specific instance of the transition system we suppose that all the transactions start together, we assume that there is a unique entry state $\sigma_0$ (formally, $\forall t \in T : {\sf ref}\ t=\sigma_0$) . In addition, since all the transactions commit together at the end, we have complete control over the shared log, and when we warp the shared log is always empty, and the shared state is identical to the initial shared state. Therefore, given these restrictions, we only need to compute a $\mu'$ such that ${\sf ref}\ t \leadsto (T,\mu', \sigma_0, \epsilon)$.

We need now to compute possible warping targets on the serialized control flow graph $tc$ (as defined in \ref{Se:concabs}) using the abstract semantics $\semanticanome{S}$. In particular, we need to compute warping that, given an entry state representing an observational equivalence class, is in an equivalence class that is reachable through a serialized execution. 

However, an abstract state in $\astate$ might represent multiple concrete states. For instance $([\statement{k} \mapsto \{n_1\}], [n_1 \mapsto \{\statement{null}, n_2\}])$ represents both that  \statement{k} is (if $n_1$ is related to $n_2$ in the abstract map) or is not (when $n_1$ is related to $\statement{null}$). This abstract state therefore might concretize to states belonging to different equivalence classes, and it cannot used to define a warping destination.

Therefore, we define a predicate $\isconcrete : \state \to \{\true, \false\}$ that, given an abstract state, holds iff it represents and exact concrete state. Formally,
\[
\begin{array}{c}
\isconcrete(e, m)\\
\Updownarrow\\
\forall \statement{x} \in \dom{e} : |e(\statement{x})|=1 \land e(\statement{x})=\{n_1\} \land \neg \isSummary(n_1)\\
\forall n \in \dom{m} : |m(n)|=1 \land m(n)=\{n_2\} \land \neg \isSummary(n_2)\\
\end{array}
\]

Note that in general the concretization of an abstract is not computable or extremely expensive. Therefore, we rely on $\isconcrete$ to check if an abstract state represents one precise concrete state.

\begin{lemma}
	$\forall (e, m) \in \Sigma : \isconcrete(e, m) \Leftrightarrow |\gamma(e, m)|=1$
\end{lemma}
\begin{proof}
	TODO
\end{proof}

The definition of $\isconcrete$ is extended to state $\phi \in \amultistate$ by checking if $\isconcrete$ holds for all the local states in $\phi$/
We build up a set of possible entry states $S \subseteq \amultistate$ such that $\forall \phi \in S : \isconcrete(\phi)$, and compute the exit states on the serialized CFG $tc$ and for all the possible entry states, filtering out only the ones that represents an exact concrete state. Note that since we have a finite number of abstract transactions, and each transaction has a finite number of parameters, we can build up a finite set of entry states representing all the possible concrete situations.

\paragraph{Running example:} XXX


After running the semantics $\semanticanome{S}$, we represent the result as a function that relates each entry state to a set of possible exit states. This is formalized by the following $\warpdestination$ function.


\[
\begin{array}{r}
\warpdestination(\set{T}, \set{S}) =[\phi \mapsto \{ \phi': \phi' \in \csemantics{S}{tc, \phi} \land\\
\isconcrete(e', m')\} : \phi \in S]\\
\end{array}
\]

\subsection{Dynamic Warping}

In our model, when we start the execution we have a finite number of concrete instances of each type of transaction. We denote by $\concretetransactions = \{s^i_j : j \in [0..m] \land i \in [1..k_j]\}$ the set of identifiers of concrete transactions, where $m$ is the number of different types of transactions, $k_j$ is the number of instances of transaction $j$, and $s^i_j$ represents the $j$-th instance of the $i$-th type of transaction.

We can then bind abstract transaction identifiers to concrete ones. Since the set of abstract transactions is defined as $\abstracttransactions = \{t^i_j : i \in [1..k], j \in \{1, 2, n\}\}$, we bind the first two concrete identifiers to the corresponding abstract identifiers, and all the others to the $n$ abstract instance. We formally define the concretization of transaction identifiers as follows:

\[
\gamma_{\concretetransactions}(T) =
[
t^i_j \mapsto 
\{
s^{i'}_j : (i \in \{1, 2\} \Rightarrow i'=i) \lor 3\leq i' \leq k_j
\} : t^i_j \in T
]
\]

We can now formalize the concretization of abstract states in $\amultistate$ by relying on the concretization of local states and transaction identifiers.

\[
\gamma_\multistate(\phi) = \{t \mapsto \sigma : \exists t' \in \dom{\phi} : t \in \gamma_{\concretetransactions}(t) \land \sigma \in \gamma_{\state}(\phi(t))\}
\]

Finally, we can prove that the warping destinations computed by $\warpdestination$ satisfies the {\sf ref} conditions as requested by the {\sf warp} rule.

\begin{theorem}
	Let $t=\warpdestination(\cset{T}, \cset{S})$ be the results computed by our system. Then, $\forall \sigma_0 \in \gamma_\multistate(\phi_0), \sigma_n \in \gamma_\multistate(\phi_n) : \phi_0 \in \dom{t} \land \phi_n \in t(\phi_0)$ we have that $\sigma_0 \leadsto \sigma_n$
\end{theorem}
\begin{proof}
	TODO
\end{proof}


Note that, since in our model we assume that all the transactions start together, $\sigma_0$ is equivalent to ${\ref t}$ for all the concrete transaction identifiers $t$.


%\section{Dynamic Warping}
%
%\newcommand\Pengt{{\cal P}eng}
%Given $\Pietrot$, the runtime system implements a function
%denoted $\Pengt : \sigma \rightarrow \hat{\sigma} \rightarrow \hat{\sigma} \rightarrow \sigma$. 
%
%
%Runtime tracks the current concrete state $\sigma$,
%current \emph{abstract state} $\hat{\sigma}$ and the last
%\emph{abstract reference state} $\hat{\sigma}_0$. Thus, we denote the runtime
%configuration as
%$$
%c =  \llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle 
%\;\;\;\text{ or, expanding }
%\llangle (\ts,g),(\Ts,G),(\Ts_0,G_0) \rrangle 
%$$
%That is, threads are in state $\ts$, shared state $g$, tracked abstract state
%$(\Ts,G)$ and tracked abstract reference state $(\Ts_0,G_0)$.
%
%There are then the following rules for steps in the runtime system:
%
%$$
%\infer=[\text{\bf Diverge}]{
%	\llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle 
%	\hookrightarrow^{*}
%	\llangle \sigma',\hat{\sigma}',\hat{\sigma}_0 \rrangle 
%}{ ... }
%$$
%
%
%$$
%\infer=[\text{\bf Warp}]{
%	\llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle
%	\hookrightarrow
%	\llangle \sigma',\hat{\sigma}',\hat{\sigma}_0 \rrangle
%}{
%\hat{\sigma}' \in \Pietrot(\hat{\sigma}_0,\red{\hat{\sigma}})
%& \sigma' = \Pengt(\sigma,\hat{\sigma},\hat{\sigma}')
%}
%$$
%
%$$
%\infer=[\text{\bf Commit}]{
%	\llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle
%	\hookrightarrow
%	\llangle \sigma',\hat{\sigma}',\hat{\sigma}' \rrangle
%}{ ... }
%$$
%
%$$
%\infer=[\text{\bf Step}]{
%	\llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle
%	\hookrightarrow
%	\llangle \sigma',\hat{\sigma}',\hat{\sigma}_0 \rrangle
%}{
%\red{fix}
%g \in \gamma(G)
%& \Ts,G \xrightarrow{P\! P} \Ts',G'
%& g' \in \gamma(G')}
%$$
%
%$\Pietrot$ ensures that $\hat{\sigma}'$ is reachable from $\hat{\sigma}_0$.
%
%$\Pengt$ ensures that $\sigma\in\gamma{\hat{\sigma}}$
%and that you awlays warp before you commit (or you always eventually
%warp)
