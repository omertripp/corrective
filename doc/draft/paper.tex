\documentclass[preprint,nocopyrightspace,10pt]{sigplanconf-pldi16}

\usepackage{caption}
\DeclareCaptionType{copyrightbox}

\usepackage{amsmath,amsthm,amssymb,stmaryrd}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{MnSymbol}
\usepackage{paralist}
\usepackage{epsfig}
\usepackage{wrapfig}
\usepackage{color}
\usepackage{program}
\usepackage{url}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{subfig} 
\usepackage{proof}
\usepackage{paralist}
\renewcommand*{\proofname}{Proof Sketch}
\usepackage{hyperref}
%\usepackage[normalem]{ulem}
\usepackage{harpoon}
\usepackage{galois}



\usepackage{supertabular}

\input{defs}
%\input{defs-pmpy}

% program listings
\usepackage{listings}
\lstset{language=java,columns=flexible,numberstyle=\tiny,showstringspaces=false,basicstyle=\sffamily} %,frame=single
\lstset{escapechar=`}
\lstset{morekeywords={
        var, val}}

\newcommand{\juc}{\lstinline+java+.\!\lstinline+util+.\lstinline+concurrent+}
\newcommand{\cConcurrentSkipListMap}{\lstinline+ConcurrentSkipListMap+}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}{Definition}[section]
\newtheorem{parameter}{Parameter}[section]
\newtheorem{property}{Property}[section]
\newtheorem{example}[equation]{Example}
\newtheorem{algorithm}[theorem]{Algorithm}

%\newenvironment{itemize*}%
%  {\begin{itemize}%
%    \setlength{\itemsep}{0.0in}%
%    \setlength{\topsep}{0.0in}%
%    \setlength{\parskip}{0.0in}}%
%  {\end{itemize}}
%\newenvironment{enumerate*}%
%  {\begin{enumerate}%
%    \setlength{\itemsep}{0.0in}%
%    \setlength{\topsep}{0.0in}%
%    \setlength{\parskip}{0.0in}}%
%  {\end{enumerate}}




% URL macro allows linebreaks on slash
\makeatletter
{\catcode`\/\active\catcode`\_\active\catcode`\.\active
\gdef\URLslash{\futurelet\next\@@URLslash}%
\gdef\@@URLslash{\ifx\next\URLslash\char`\/\else\slash\fi}%
\gdef\URLdot{\char`\.\penalty\exhyphenpenalty}%
\gdef\URLprepare{\catcode`\/\active\catcode`\_\active\catcode`\.\active
        \let/\URLslash\let.\URLdot\def~{\char`\~}\def_{\char`\_}}}%
\def\URL{\bgroup\URLprepare\realURL}%
\def\realURL#1{\tt #1\egroup}%




\newcommand\figbox[1]{\noindent{\ \\\fbox{\begin{minipage}{3.2in}
#1
\end{minipage}
}}}

\newcommand\figboxB[1]{\noindent{\ \\\fbox{\begin{minipage}{6.5in}
#1
\end{minipage}
}}}

\input{pietromacro}

\begin{document}

\title{Corrective Synchronization}

% \authorinfo{Pietro Ferrara} {} {} 
%\authorinfo{Omer Tripp} {} {}
% \authorinfo{Peng Liu} {} {} 
% \authorinfo{Eric Koskinen} {} {} 

\authorinfo{}{}{}
\maketitle

\begin{abstract}
Concurrency control is a challenging problem. While some thread interleavings are admissible, there are certain interleaving scenarios that lead to inadmissible program states. Broadly speaking, there are two main paradigms for avoiding such situations: \emph{pessimistic synchronization} reduces parallelism to mitigate interference between threads, while \emph{optimistic synchronization} detects when illegal interleavings have occurred and rolls execution (of one or more threads) back to an admissible point.

We propose a novel synchronization paradigm. In our approach, dubbed \emph{corrective synchronization}, the correctness of multithreaded execution is enforced neither by reducing parallelism nor by rolling back illegal thread interleavings, but by correcting the inadmissible state after the fact. The system automatically compensates, if necessary, for the effects of inadmissible interleavings by modifying the program state as a transaction completes while accounting for the behavior of concurrent transactions. We have proven that corrective synchronization is serializable.

Within the general scope of corrective synchronization, we explore the combination of (i) offline static analysis to compute correct states w.r.t. the entry states with (ii) a runtime protocol that utilizes the artifacts computed statically to perform online state correction. We instantiate this setup to clients of the Java {\sf ConcurrentMap} abstract data type (ADT) to ensure safe composition of map operations.

We have created a prototype implementation of this system in Java, which we compare against two mainstream techniques: a lock-based approach boosted with abstract {\sf Map} semantics as well as a standard software transactional memory (STM). Our experimental evaluation on several real-world benchmarks indicates x2 speedup improvement compared to these techniques. Further, our technique incurs negligible overhead as compared to the original execution.
\end{abstract}

\input{introduction}

\input{overview}

%\includegraphics[width=3.2in]{simulation.eps}

%\input{prelim}

%\input{pushpull}

%\input{warp}


\newcommand{\pengtodo}[1]{{\bf #1}}
\newcommand{\pietrotodo}[1]{{\bf #1}}


\input{newformal}
%
%\input{language}

\input{static}

%\input{dynamic}


%\pagebreak
%\onecolumn


\input{experimentalresults}

\input{relatedwork}

\input{conclusion}

{%\footnotesize\linespread{0.9}
\bibliographystyle{acm}
%\bibliography{nopages}
\bibliography{biblio}
}


\newpage
\appendix
\input{casestudies}

%\section{Complete \PMPY{} rules}
%\input{bigfig}

%\input{old}

%\input{pietroformal}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
